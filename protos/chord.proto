
syntax = "proto3";
package chord;

import "google/protobuf/empty.proto";

service Node {

  // Application Level RPC Calls

  // Once a client knows the node to connect to, it can fetch the data
  rpc fetch (UserRequest) returns (User) {}
  // Once a client knows the node to connect to, we can insert the user at that node.
  rpc insert (User) returns (google.protobuf.Empty) {}

  // Chord Library Level RPC Calls
  rpc findSuccessor (NodeId) returns (NodeAddress) {}
//  rpc findPredecessor (NodeId) returns (NodeAddress) {}
  rpc getSuccessor (NodeAddress) returns (NodeAddress) {}
  rpc getPredecessor (NodeAddress) returns (NodeAddress) {}
  rpc setPredecessor (NodeAddress) returns (google.protobuf.Empty) {}
  rpc setSuccessor (NodeAddress) returns (google.protobuf.Empty) {}
  rpc notify (NodeAddress) returns (google.protobuf.Empty) {}
  rpc closestPrecedingFinger (NodeAddress) returns (NodeAddress) {}
  rpc update_finger_table (FingerTableEntry) returns (NodeAddress) {}
  rpc summary(Trash) returns (NodeAddress) {}
}

message NodeId {
  uint32 id = 1;
}

message NodeAddress {
  uint32 id = 1;
  string ip = 2;
  uint32 port = 3;
}

message Trash{
  uint32 id = 1;
}

// message Summary{
//   message NodeAddress {
//     uint32 id = 1;
//     string ip = 2;
//     uint32 port = 3;
//   }
// }


 message FingerTableEntry {
  NodeAddress node = 1;
  uint32 index = 2;
 }

// The request message containing the user's name.
message UserRequest {
  int32 id = 1;
}

// A User seems to have a local Id and profile associated with the StackOverflow group. These Ids are tied together via AccountIds
// For the chord project, I think we can just hash off the Id key, since these are unique.
message User {
  int32 id = 1;
  int32 reputation = 2;
  string creationDate = 3;
  string displayName = 4;
  string lastAccessDate = 5;
  string websiteUrl = 6;
  string location = 7;
  string aboutMe = 8;
  int32 views = 9;
  int32 upVotes = 10;
  int32 downVotes = 11;
  string profileImageUrl = 12;
  int32 accountId = 13;
}
